FEATURE REQUEST FOR REPLIT AGENT: 4 NEW TROUBLESHOOTING CAPABILITIES

================================================================================
OVERVIEW
================================================================================

Please implement these 4 features to extend the AI troubleshooting API. All should be read-only, authenticated with AI_ASSISTANT_TOKEN or ADMIN_TOKEN, and added to src/routes/troubleshoot.js.


================================================================================
FEATURE 1: APPLICATION LOG READING
================================================================================

ENDPOINT:
GET /api/troubleshoot/logs/application

QUERY PARAMETERS:
- since (optional): ISO timestamp to filter logs after this time
- level (optional): Filter by log level (info, warn, error)
- limit (optional): Max number of logs to return (default: 100)
- search (optional): Search for text in log messages

PURPOSE:
Capture and expose console.log/console.error/console.warn output from the Node.js application so AI can read application logs without needing shell access.

IMPLEMENTATION PART 1 - Add to src/server.js at the top after imports:

const LOG_BUFFER = [];
const MAX_LOG_BUFFER_SIZE = 1000;

function captureLog(level, ...args) {
  const message = args.map(arg => 
    typeof arg === 'object' ? JSON.stringify(arg) : String(arg)
  ).join(' ');
  
  LOG_BUFFER.push({
    timestamp: new Date().toISOString(),
    level: level,
    message: message
  });
  
  if (LOG_BUFFER.length > MAX_LOG_BUFFER_SIZE) {
    LOG_BUFFER.shift();
  }
}

const originalLog = console.log;
const originalError = console.error;
const originalWarn = console.warn;

console.log = function(...args) {
  captureLog('info', ...args);
  originalLog.apply(console, args);
};

console.error = function(...args) {
  captureLog('error', ...args);
  originalError.apply(console, args);
};

console.warn = function(...args) {
  captureLog('warn', ...args);
  originalWarn.apply(console, args);
};

global.LOG_BUFFER = LOG_BUFFER;


IMPLEMENTATION PART 2 - Add to src/routes/troubleshoot.js:

router.get('/logs/application', async (req, res) => {
  try {
    const { since, level, limit = 100, search } = req.query;
    
    let logs = global.LOG_BUFFER || [];
    
    if (since) {
      logs = logs.filter(log => log.timestamp >= since);
    }
    
    if (level) {
      logs = logs.filter(log => log.level === level);
    }
    
    if (search) {
      const searchLower = search.toLowerCase();
      logs = logs.filter(log => log.message.toLowerCase().includes(searchLower));
    }
    
    logs = logs.slice(-parseInt(limit));
    
    res.json({
      ok: true,
      logs: logs,
      count: logs.length,
      buffer_size: (global.LOG_BUFFER || []).length
    });
  } catch (error) {
    console.error('[troubleshoot/logs/application] Error:', error);
    res.status(500).json({ 
      ok: false, 
      error: { 
        code: 'INTERNAL_ERROR',
        message: 'Failed to retrieve application logs' 
      } 
    });
  }
});


================================================================================
FEATURE 2: SYSTEM METRICS
================================================================================

ENDPOINT:
GET /api/troubleshoot/metrics

PURPOSE:
Provide real-time performance metrics about the system's health and efficiency.

IMPLEMENTATION - Add to src/routes/troubleshoot.js:

router.get('/metrics', async (req, res) => {
  try {
    const messageMetrics = await query(`
      SELECT 
        COUNT(*) FILTER (WHERE direction = 'out') as total_sent,
        COUNT(*) FILTER (WHERE direction = 'out' AND status = 'sent') as successful,
        COUNT(*) FILTER (WHERE direction = 'out' AND status = 'failed') as failed,
        AVG(EXTRACT(EPOCH FROM (delivered_at - created_at))) FILTER (WHERE delivered_at IS NOT NULL) as avg_delivery_time_seconds
      FROM messages
      WHERE created_at > NOW() - INTERVAL '24 hours'
    `);
    
    const buttonMetrics = await query(`
      SELECT 
        COUNT(DISTINCT t.id) as total_tickets,
        COUNT(DISTINCT t.id) FILTER (WHERE t.button_clicked IS NOT NULL) as responded_tickets,
        AVG(EXTRACT(EPOCH FROM (t.updated_at - t.created_at))) FILTER (WHERE t.button_clicked IS NOT NULL) as avg_response_time_seconds
      FROM tickets t
      WHERE t.created_at > NOW() - INTERVAL '24 hours'
    `);
    
    const msgRow = messageMetrics.rows[0];
    const btnRow = buttonMetrics.rows[0];
    
    const totalSent = parseInt(msgRow.total_sent) || 0;
    const successful = parseInt(msgRow.successful) || 0;
    const failed = parseInt(msgRow.failed) || 0;
    
    const totalTickets = parseInt(btnRow.total_tickets) || 0;
    const respondedTickets = parseInt(btnRow.responded_tickets) || 0;
    
    res.json({
      ok: true,
      data: {
        timestamp: new Date().toISOString(),
        period: 'last_24_hours',
        message_delivery: {
          total_sent: totalSent,
          successful: successful,
          failed: failed,
          success_rate_percent: totalSent > 0 ? ((successful / totalSent) * 100).toFixed(2) : 0,
          avg_delivery_time_seconds: parseFloat(msgRow.avg_delivery_time_seconds) || null
        },
        button_responses: {
          total_tickets: totalTickets,
          responded_tickets: respondedTickets,
          response_rate_percent: totalTickets > 0 ? ((respondedTickets / totalTickets) * 100).toFixed(2) : 0,
          avg_response_time_seconds: parseFloat(btnRow.avg_response_time_seconds) || null
        },
        system: {
          uptime_seconds: process.uptime(),
          memory_mb: (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2),
          node_version: process.version
        }
      }
    });
  } catch (error) {
    console.error('[troubleshoot/metrics] Error:', error);
    res.status(500).json({ 
      ok: false, 
      error: { 
        code: 'INTERNAL_ERROR',
        message: 'Failed to retrieve metrics' 
      } 
    });
  }
});


================================================================================
FEATURE 3: TIME-SERIES ANALYTICS
================================================================================

ENDPOINT:
GET /api/troubleshoot/analytics/timeseries

QUERY PARAMETERS:
- metric (required): Metric to track (tickets, messages, button_clicks)
- interval (optional): Time bucket (1h, 1d, 1w) - default: 1h
- since (optional): Start date (ISO timestamp)
- until (optional): End date (ISO timestamp)

PURPOSE:
Provide historical trend data for visualizing patterns over time.

IMPLEMENTATION - Add to src/routes/troubleshoot.js:

router.get('/analytics/timeseries', async (req, res) => {
  try {
    const { metric, interval = '1h', since, until } = req.query;
    
    if (!metric) {
      return res.status(400).json({
        ok: false,
        error: {
          code: 'MISSING_PARAMETER',
          message: 'metric parameter is required'
        }
      });
    }
    
    const intervalMap = {
      '1h': '1 hour',
      '1d': '1 day',
      '1w': '1 week'
    };
    const pgInterval = intervalMap[interval] || '1 hour';
    
    const sinceClause = since ? `AND created_at >= '${since}'` : `AND created_at > NOW() - INTERVAL '7 days'`;
    const untilClause = until ? `AND created_at <= '${until}'` : '';
    
    let sql;
    
    if (metric === 'tickets') {
      sql = `
        SELECT 
          DATE_TRUNC('${pgInterval.split(' ')[1]}', created_at) as time_bucket,
          COUNT(*) as count,
          COUNT(*) FILTER (WHERE status = 'open') as open_count,
          COUNT(*) FILTER (WHERE status = 'closed') as closed_count
        FROM tickets
        WHERE 1=1 ${sinceClause} ${untilClause}
        GROUP BY time_bucket
        ORDER BY time_bucket ASC
      `;
    } else if (metric === 'messages') {
      sql = `
        SELECT 
          DATE_TRUNC('${pgInterval.split(' ')[1]}', created_at) as time_bucket,
          COUNT(*) as count,
          COUNT(*) FILTER (WHERE direction = 'out' AND status = 'sent') as sent_count,
          COUNT(*) FILTER (WHERE direction = 'out' AND status = 'failed') as failed_count
        FROM messages
        WHERE 1=1 ${sinceClause} ${untilClause}
        GROUP BY time_bucket
        ORDER BY time_bucket ASC
      `;
    } else if (metric === 'button_clicks') {
      sql = `
        SELECT 
          DATE_TRUNC('${pgInterval.split(' ')[1]}', created_at) as time_bucket,
          COUNT(*) as count,
          COUNT(*) FILTER (WHERE metadata->>'payload' = 'Test') as test_clicks,
          COUNT(*) FILTER (WHERE metadata->>'payload' = 'Maintenance') as maintenance_clicks,
          COUNT(*) FILTER (WHERE metadata->>'payload' = 'Entrapment') as entrapment_clicks
        FROM event_log
        WHERE event_type = 'button_click_received'
          ${sinceClause} ${untilClause}
        GROUP BY time_bucket
        ORDER BY time_bucket ASC
      `;
    } else {
      return res.status(400).json({
        ok: false,
        error: {
          code: 'INVALID_METRIC',
          message: 'Valid metrics: tickets, messages, button_clicks'
        }
      });
    }
    
    const result = await query(sql);
    
    res.json({
      ok: true,
      data: {
        metric: metric,
        interval: interval,
        since: since || 'last_7_days',
        until: until || 'now',
        datapoints: result.rows
      }
    });
  } catch (error) {
    console.error('[troubleshoot/analytics/timeseries] Error:', error);
    res.status(500).json({ 
      ok: false, 
      error: { 
        code: 'INTERNAL_ERROR',
        message: 'Failed to retrieve time-series data' 
      } 
    });
  }
});


================================================================================
FEATURE 4: REAL-TIME MONITORING (SERVER-SENT EVENTS)
================================================================================

ENDPOINT:
GET /api/troubleshoot/stream/events

PURPOSE:
Provide real-time updates about system events via Server-Sent Events (SSE) so AI can watch the system in real-time without polling.

IMPLEMENTATION - Add to src/routes/troubleshoot.js:

router.get('/stream/events', async (req, res) => {
  res.writeHead(200, {
    'Content-Type': 'text/event-stream',
    'Cache-Control': 'no-cache',
    'Connection': 'keep-alive'
  });
  
  res.write(`data: ${JSON.stringify({ type: 'connected', timestamp: new Date().toISOString() })}\n\n`);
  
  const sendEvent = (event) => {
    res.write(`data: ${JSON.stringify(event)}\n\n`);
  };
  
  const originalLogEvent = global.logEvent;
  
  const wrappedLogEvent = async (event_type, data = {}) => {
    if (originalLogEvent) {
      await originalLogEvent(event_type, data);
    }
    
    sendEvent({
      type: event_type,
      data: data,
      timestamp: new Date().toISOString()
    });
  };
  
  global.logEvent = wrappedLogEvent;
  
  const heartbeat = setInterval(() => {
    res.write(`: heartbeat\n\n`);
  }, 30000);
  
  req.on('close', () => {
    clearInterval(heartbeat);
    global.logEvent = originalLogEvent;
    res.end();
  });
});

NOTE: For production, you'd want a proper event emitter system, but this provides basic real-time streaming.


================================================================================
TESTING THE NEW ENDPOINTS
================================================================================

Test Application Logs:
curl -H "X-AI-Token: YOUR_TOKEN" "https://gplifts.woosh.ai/api/troubleshoot/logs/application?limit=50&level=error"

Test System Metrics:
curl -H "X-AI-Token: YOUR_TOKEN" "https://gplifts.woosh.ai/api/troubleshoot/metrics"

Test Time-Series Analytics:
curl -H "X-AI-Token: YOUR_TOKEN" "https://gplifts.woosh.ai/api/troubleshoot/analytics/timeseries?metric=tickets&interval=1d"

Test Real-Time Stream:
curl -H "X-AI-Token: YOUR_TOKEN" "https://gplifts.woosh.ai/api/troubleshoot/stream/events"


================================================================================
SUMMARY
================================================================================

These 4 features provide:
1. Application Logs - Read console output for debugging
2. System Metrics - Real-time performance statistics
3. Time-Series Analytics - Historical trend data
4. Real-Time Monitoring - Live event streaming

All endpoints are:
- Read-only (safe)
- Authenticated (secure)
- Rate-limited (protected)
- Audited (compliant)

Please implement these in src/routes/troubleshoot.js and update src/server.js for the log capture system.

